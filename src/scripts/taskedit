#!/usr/bin/python2.5

import gtk
import gobject

is_hildon_app = True
try:
    import hildon
except ImportError:
    is_hildon_app = False

import freenav.freedb
import freenav.projection

TASKS = 'ABCDEFGH'
NUM_TASKS = len(TASKS)

RAD1 = 0.5
ANG1 = 360
RAD2 = 0
ANG2 = 0
START_RAD = 3
FINISH_RAD = 0.5

TP_DIRNS = ['SYM', 'NEXT', 'PREV', 'FIX']

def make_tp(wp_id, rad1=RAD1, ang1=ANG1, rad2=RAD2, ang2=ANG2, dirn='SYM',
            ang12=0):
    return {'wp_id': wp_id,
            'rad1': rad1, 'ang1': ang1,
            'rad2': rad2, 'ang2': ang2,
            'dirn': dirn, 'ang12': ang12}

def make_start_tp(wp_id, rad1=START_RAD, dirn='NEXT', ang12=0):
    return make_tp(wp_id, rad1=rad1, dirn=dirn, ang12=ang12)

def make_finish_tp(wp_id, rad1=FINISH_RAD, dirn='PREV', ang12=0):
    return make_tp(wp_id, rad1=rad1, dirn=dirn, ang12=ang12)

if is_hildon_app:
    AppBase = hildon.Program
else:
    AppBase = object

class OzDialog(gtk.Dialog):
    def __init__(self, parent, task, tp_index):
        tp = task[tp_index]
        title = 'Obs. Zone - ' + tp['wp_id']
        gtk.Dialog.__init__(self, title, parent,
                            gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
                            (gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT,
                             gtk.STOCK_OK, gtk.RESPONSE_OK))

        table = gtk.Table(6, 2, True)
        table.set_col_spacing(0, 5)
        table.set_row_spacings(3)
        for n, txt in enumerate(['Radius1 (m)', 'Angle1 (deg)',
                                 'Radius2 (m)', 'Angle2 (deg)',
                                 'Dirn', 'Angle12 (deg)']):
            label = gtk.Label(txt)
            label.set_alignment(1, 0.5)
            table.attach(label, 0, 1, n, n + 1)

        rad1_adj = gtk.Adjustment(tp['rad1'], 0, 50000, 100)
        ang1_adj = gtk.Adjustment(tp['ang1'], 0, 360, 1)
        rad2_adj = gtk.Adjustment(tp['rad2'], 0, 0, 50000, 100)
        ang2_adj = gtk.Adjustment(tp['ang2'], 0, 0, 360, 1)
        ang12_adj = gtk.Adjustment(tp['ang12'], 0, 360, 1)

        rad1_spin = gtk.SpinButton(rad1_adj, 0, 0)
        ang1_spin = gtk.SpinButton(ang1_adj, 0, 1)
        rad2_spin = gtk.SpinButton(rad2_adj, 0, 0)
        ang2_spin = gtk.SpinButton(ang2_adj, 0, 1)
        ang12_spin = gtk.SpinButton(ang12_adj, 0, 1)

        for s in [rad1_spin, ang1_spin, rad2_spin, ang2_spin, ang12_spin]:
            s.set_numeric(True)
        ang12_spin.set_wrap(True)

        table.attach(rad1_spin, 1, 2, 0, 1)
        table.attach(ang1_spin, 1, 2, 1, 2)
        table.attach(rad2_spin, 1, 2, 2, 3)
        table.attach(ang2_spin, 1, 2, 3, 4)
        table.attach(ang12_spin, 1, 2, 5, 6)

        combobox = gtk.combo_box_new_text()
        for d in TP_DIRNS:
            combobox.append_text(d)
        combobox.set_active(TP_DIRNS.index(tp['dirn']))
        table.attach(combobox, 1, 2, 4, 5)

        self.vbox.pack_start(table)
        self.show_all()

class TaskApp(AppBase):
    def __init__(self):
        AppBase.__init__(self)

        self.task_db = freenav.freedb.Freedb()

        p = self.task_db.get_projection()
        self.projection = freenav.projection.Lambert(
            p['Parallel1'], p['Parallel2'], p['Ref_Lat'], p['Ref_Lon'])

        self.task_index, self.tasks = self.load_tasks()

        # Create window and add event handlers
        if is_hildon_app:
            self.window = hildon.Window()
        else:
            self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.window.set_title('Task')
        self.window.set_border_width(3)
        self.window.connect('destroy', gtk.main_quit)
        self.window.connect('delete_event', self.on_quit)
        self.window.connect('key-press-event', self.on_keypress)
        self.window.connect('window-state-event', self.on_window_state_change)

        # Create waypoint list
        wp_store = gtk.ListStore(gobject.TYPE_STRING, gobject.TYPE_STRING)
        for wp in self.task_db.get_waypoint_list():
            wp_store.append((wp['Id'], wp['Name']))

        cell = gtk.CellRendererText()

        col1 = gtk.TreeViewColumn('ID')
        col1.pack_start(cell, True)
        col1.add_attribute(cell, 'text', 0)
        col1.set_sort_column_id(0)

        col2 = gtk.TreeViewColumn('Name')
        col2.pack_start(cell, True)
        col2.add_attribute(cell, 'text', 1)
        col2.set_sort_column_id(1)

        wp_view = gtk.TreeView(wp_store)
        wp_view.set_headers_visible(True)
        wp_view.append_column(col1)
        wp_view.append_column(col2)
        wp_view.connect('row-activated', self.on_wp_activated, wp_store)

        wp_window = gtk.ScrolledWindow()
        wp_window.add(wp_view)

        # Create task list
        self.task_saved = True
        self.task_store = gtk.ListStore(gobject.TYPE_STRING)
        self.update_task_store()

        col = gtk.TreeViewColumn('ID')
        col.pack_start(cell, True)
        col.add_attribute(cell, 'text', 0)

        self.task_view = gtk.TreeView(self.task_store)
        self.task_view.set_headers_visible(False)
        self.task_view.set_reorderable(True)
        self.task_view.append_column(col)
        self.task_view.connect('row-activated', self.on_wp_activated,
                               self.task_store)

        # Task distance
        self.dist_label = gtk.Label('')
        self.dist_label.set_alignment(1, 0)

        # Waypoint delete
        del_button = gtk.Button('Del')
        del_button.connect('clicked', self.on_tp_delete)

        # Observation zone set...
        oz_button = gtk.Button('OZ...')
        oz_button.connect('clicked', self.on_oz_set)

        # Task select
        combobox = gtk.combo_box_new_text()
        for t in TASKS:
            combobox.append_text(t)
        combobox.set_active(self.task_index)
        combobox.connect('changed', self.on_task_select)

        # Task save
        save_button = gtk.Button('Save')
        save_button.connect('clicked', self.on_save)

        # Packing
        vbox = gtk.VBox()
        vbox.set_spacing(5)
        vbox.pack_start(self.task_view, expand=True)
        vbox.pack_start(self.dist_label, expand=False)
        vbox.pack_start(del_button, expand=False)
        vbox.pack_start(oz_button, expand=False)
        vbox.pack_start(gtk.HSeparator(), expand=False)
        vbox.pack_end(save_button, expand=False)
        vbox.pack_end(combobox, expand=False)

        hbox = gtk.HBox()
        hbox.set_spacing(3)
        hbox.pack_start(wp_window, expand=True)
        hbox.pack_end(vbox, expand=False)
        self.window.add(hbox)

        # Drag and drop
        wp_view.enable_model_drag_source(gtk.gdk.BUTTON1_MASK,
            [('WP_MODEL_ROW', gtk.TARGET_SAME_APP, 0)],
            gtk.gdk.ACTION_COPY)
        wp_view.connect('drag-data-get', self.on_wp_drag_data_get)

        self.task_view.enable_model_drag_source(gtk.gdk.BUTTON1_MASK,
            [('TASK_MODEL_ROW', gtk.TARGET_SAME_WIDGET, 0)],
            gtk.gdk.ACTION_COPY)
        self.task_view.enable_model_drag_dest(
            [('TASK_MODEL_ROW', gtk.TARGET_SAME_WIDGET, 0),
             ('WP_MODEL_ROW', gtk.TARGET_SAME_APP, 0)],
            gtk.gdk.ACTION_DEFAULT)
        self.task_view.connect('drag-data-get', self.on_task_drag_data_get)
        self.task_view.connect('drag-data-received',
                               self.on_drag_data_received)

        self.update_distance()

    def on_quit(self, widget, event, data=None):
        if not self.task_saved:
            dialog = gtk.MessageDialog(buttons=gtk.BUTTONS_YES_NO,
                message_format='Task updated, are you sure you want to quit?',
                type=gtk.MESSAGE_QUESTION)
            ret = dialog.run()
            dialog.destroy()
            return (ret == gtk.RESPONSE_NO)

    def on_window_state_change(self, widget, event, *args):
        if event.new_window_state & gtk.gdk.WINDOW_STATE_FULLSCREEN:
            self.window_in_fullscreen = True
        else:
            self.window_in_fullscreen = False

    def on_keypress(self, widget, event, *args):
        if event.keyval == gtk.keysyms.F6:
            if self.window_in_fullscreen:
                self.window.unfullscreen()
            else:
                self.window.fullscreen()

    def on_save(self, button):
        for i in range(NUM_TASKS):
            self.task_db.set_task(self.tasks[i], i)
        self.task_db.set_task_id(self.task_index)
        self.task_saved = True

    def on_wp_activated(self, treeview, path, column, model):
        id = model[path][0]
        wp = self.task_db.get_waypoint(id)
        msg = "%s\n%s\n%s\n%s" % (id, wp['Name'], wp['Turnpoint'],
                                  wp['Comment'])
        md = gtk.MessageDialog(None, gtk.DIALOG_MODAL, gtk.MESSAGE_INFO, 
                               gtk.BUTTONS_CLOSE, msg)
        md.run()
        md.destroy()

    def on_tp_delete(self, button):
        selection = self.task_view.get_selection()
        model, iter = selection.get_selected()
        if iter:
            path = model.get_path(iter)
            self.delete_tp(path[0])
            self.update_task_store()

            n = len(model)
            if n > 0:
                if n == path[0]:
                    selection.select_path(n-1)
                else:
                    selection.select_path(path)

        self.update_distance()
        self.task_saved = False

    def on_oz_set(self, button):
        selection = self.task_view.get_selection()
        model, iter = selection.get_selected()
        if iter:
            path = model.get_path(iter)
            dialog = OzDialog(self.window, self.tasks[self.task_index],
                              path[0])
            dialog.run()
            dialog.destroy()

    def on_task_select(self, combobox):
        self.task_index = combobox.get_active()
        self.update_task_store()
        self.task_saved = False
        self.update_distance()

    def on_wp_drag_data_get(self, view, context, selection, info, etime):
        sel = view.get_selection()
        model, iter = sel.get_selected()
        id = model.get_value(iter, 0)
        selection.set('WP_DATA', 8, id)

    def on_task_drag_data_get(self, view, context, selection, info, etime):
        sel = view.get_selection()
        model, paths = sel.get_selected_rows()
        row = paths[0][0]
        selection.set('TASK_DATA', 8, str(row))

    def on_drag_data_received(self, view, context, x, y, selection, info,
                              etime):
        model = view.get_model()
        drop_info = view.get_dest_row_at_pos(x, y)
        if drop_info:
            path, position = drop_info
            if (position == gtk.TREE_VIEW_DROP_BEFORE or
                position == gtk.TREE_VIEW_DROP_INTO_OR_BEFORE):
                drop_posn = path[0]
            else:
                drop_posn = path[0] + 1
        else:
            drop_posn = len(model)

        if selection.type == 'WP_DATA':
            self.insert_tp(selection.data, drop_posn)
        else:
            from_posn = int(selection.data)
            self.move_tp(from_posn, drop_posn)

        self.update_task_store()

        self.update_distance()
        self.task_saved = False

    def load_tasks(self):
        """Get tasks and task index from database"""
        tasks =[] 
        for i in range(NUM_TASKS):
            tasks.append(self.task_db.get_task(i))

        task_index = self.task_db.get_task_id()
        return (task_index, tasks)

    def update_task_store(self):
        """Load waypoint list into task view ListStore"""
        self.task_store.clear()
        for tp in self.tasks[self.task_index]:
            self.task_store.append((tp['wp_id'],))

    def insert_tp(self, wp_id, posn):
        task = self.tasks[self.task_index]
        task_len = len(task)

        if task_len == 0:
            task.append(make_tp(wp_id))
        else:
            if posn == 0:
                old_start_id = task[0]['wp_id']
                if task_len == 1:
                    task[0] = make_finish_tp(old_start_id)
                else:
                    task[0] = make_tp(old_start_id)
                task.insert(0, make_start_tp(wp_id))

            elif posn == task_len:
                old_finish_id = task[-1]['wp_id']
                if task_len == 1:
                    task[0] = make_start_tp(old_finish_id)
                else:
                    task[-1] = make_tp(old_finish_id)
                task.append(make_finish_tp(wp_id))

            else:
                task.insert(posn, make_tp(wp_id))

    def delete_tp(self, posn):
        task = self.tasks[self.task_index]
        del task[posn]
        task_len = len(task)

        if task_len == 1:
            wp_id = task[0]['wp_id']
            task[0] = make_tp(wp_id)
        elif task_len > 1:
            if posn == 0:
                wp_id = task[0]['wp_id']
                task[0] = make_start_tp(wp_id)
            elif posn == task_len:
                wp_id = task[-1]['wp_id']
                task[-1] = make_finish_tp(wp_id)

    def move_tp(self, from_posn, to_posn):
        task = self.tasks[self.task_index]

        if (from_posn != to_posn) and (from_posn != to_posn - 1):
            print "Move"
            wp_id = task[from_posn]['wp_id']
            self.delete_tp(from_posn)

            if to_posn < from_posn:
                self.insert_tp(wp_id, to_posn)
            else:
                self.insert_tp(wp_id, to_posn - 1)

    def update_distance(self):
        wp_list = [tp['wp_id'] for tp in self.tasks[self.task_index]]
        dist = self.calc_distance(wp_list)
        self.dist_label.set_text('%.1fkm' % (dist / 1000))

    def calc_distance(self, wp_list):
        if len(wp_list) <= 1:
            return 0
        else:
            w1 = self.task_db.get_waypoint(wp_list[0])
            w2 = self.task_db.get_waypoint(wp_list[1])
            dist = (self.projection.dist(w1['X'], w1['Y'], w2['X'], w2['Y']) +
                    self.calc_distance(wp_list[1:]))
            return dist

    def run(self):
        self.window.show_all()
        gtk.main()

if __name__ == '__main__':
    task_app = TaskApp()
    task_app.run()
